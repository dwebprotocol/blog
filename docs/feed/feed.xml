<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
	<title>The Hypercore Protocol Blog</title>
	<subtitle>News and thoughts from the Hypercore Protocol team.</subtitle>
	
	<link href="https://blog.hypercore-protocol.org/feed/feed.xml" rel="self"/>
	<link href="https://blog.hypercore-protocol.org/"/>
	<updated>2020-09-17T02:00:00+02:00</updated>
	<id>https://blog.hypercore-protocol.org/</id>
	<author>
		<name>Andrew Osheroff</name>
		<email>andrewosh@gmail.com</email>
	</author>
	
	<entry>
		<title>Announcing Hyperdrive v10</title>
		<link href="https://blog.hypercore-protocol.org/posts/announcing-hyperdrive-10/"/>
		<updated>2020-05-14T02:00:00+02:00</updated>
		<id>https://blog.hypercore-protocol.org/posts/announcing-hyperdrive-10/</id>
		<content type="html">&lt;p&gt;For the past year, we&#39;ve been working hard on the v10 release of Hyperdrive. After a long period of beta testing, we&#39;re excited to announce that it&#39;s ready for general use!&lt;/p&gt;
&lt;p&gt;Hyperdrive is a peer-to-peer filesystem that&#39;s designed to help you share files quickly and safely, directly from your computer. Hyperdrive v9, along with many other modules prefixed by &#39;hyper&#39;, has served as the backbone for &lt;a href=&quot;https://dat.foundation/&quot;&gt;Dat&lt;/a&gt; for many years -- you might already be familiar with Hyperdrive if you&#39;ve dug into Dat&#39;s internals.&lt;/p&gt;
&lt;p&gt;Leading up to this release, we&#39;ve done a bit of restructuring: Hyperdrive and its many hyper-siblings now live under a small, technically-focused brand/organization called the &lt;a href=&quot;https://hypercore-protocol.org/&quot;&gt;Hypercore Protocol&lt;/a&gt;. Practically, this change means very little beyond branding, but we&#39;re hoping it will give the modules a chance to shine on their own. In light of that, here&#39;s a look inside Hyperdrive.&lt;/p&gt;
&lt;p&gt;In this post we&#39;ll step through some of the improvements we&#39;ve made in v10, explain how Hyperdrive fits into the broader Hypercore Protocol ecosystem, and show you how to get started using it. This release is only the beginning, and we describe our next steps in the &lt;a href=&quot;#looking-forward&quot;&gt;&amp;quot;Looking Forward&amp;quot;&lt;/a&gt; section.&lt;/p&gt;
&lt;p&gt;Here&#39;s the TL;DR:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Improved Indexing&lt;/strong&gt;: We&#39;re using a new &lt;a href=&quot;https://en.wikipedia.org/wiki/Hash_array_mapped_trie&quot;&gt;HAMT&lt;/a&gt;-based indexing structure called a &lt;a href=&quot;https://github.com/hypercore-protocol/hypertrie&quot;&gt;Hypertrie&lt;/a&gt;, which gives huge perf/scaling boosts.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Mounts&lt;/strong&gt;: You can now &amp;quot;link&amp;quot; other peoples&#39; drives into your own.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Hyperdrive Daemon&lt;/strong&gt;: We&#39;ve created a cross-platform daemon that provides both FUSE and gRPC access to daemon-managed drives.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Better Foundations&lt;/strong&gt;: We&#39;ve recently introduced the &lt;a href=&quot;https://hypercore-protocol.org/#hyperswarm&quot;&gt;Hyperswarm&lt;/a&gt; DHT, and improvements to the &lt;a href=&quot;https://github.com/hypercore-protocol/hypercore-protocol&quot;&gt;Hypercore protocol&lt;/a&gt;, which have helped make our whole stack snappier and more reliable.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;what&#39;s-hyperdrive%3F&quot;&gt;What&#39;s Hyperdrive? &lt;a class=&quot;direct-link&quot; href=&quot;#what&#39;s-hyperdrive%3F&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Hyperdrive is a POSIX-like filesystem implementation, written in Node.js, that&#39;s designed to be the storage layer for fast, scalable, and secure peer-to-peer applications. For most developers, working with a Hyperdrive should feel just like using Node&#39;s standard &lt;code&gt;fs&lt;/code&gt; module, with only minor additions. Our main goal has always been to make it possible to share entire filesystems with others using a single 32-byte key (i.e. &lt;code&gt;hyper://ab13d...&lt;/code&gt;). We&#39;ll refer to Hyperdrive filesystems as &amp;quot;drives&amp;quot; from here on out.&lt;/p&gt;
&lt;p&gt;Drives are great for applications in which a single writer wants to distribute large, mutable collections of files to many readers. A file collection might be a video library, a personal blog, a scientific dataset, or what have you. Like BitTorrent, peers can download files from other peers without sacrificing trust (drive contents are signed by the original author).&lt;/p&gt;
&lt;p&gt;Unlike BitTorrent, files can be added or modified after a drive is created, and peers can &amp;quot;watch&amp;quot; a drive for updates, meaning update notifications are dispatched to readers in &lt;strong&gt;realtime&lt;/strong&gt;!&lt;/p&gt;
&lt;p&gt;Importantly, drives support efficient random-access file reads, meaning that you can seek through a video and it will download only the portions of the video you&#39;re viewing, on-demand. We call this property &amp;quot;sparse downloading&amp;quot;, and it&#39;s great for things like large websites (think all of Wikipedia mirrored to a drive) where readers only view single pages at a time.&lt;/p&gt;
&lt;p&gt;Here&#39;s an example of sparsely downloading images from a large drive:&lt;/p&gt;
&lt;div class=&quot;video-container-lg&quot; id=&quot;van-gogh-vid&quot;&gt;
  &lt;video src=&quot;https://blog.hypercore-protocol.org/video/van_gogh.mp4&quot; autoplay=&quot;&quot; loop=&quot;&quot; muted=&quot;&quot; playsinline=&quot;&quot;&gt;&lt;/video&gt;
&lt;/div&gt;
&lt;p&gt;Under the hood, Hyperdrive is built using two append-only log data structures called &lt;a href=&quot;https://github.com/mafintosh/hypercore&quot;&gt;Hypercores&lt;/a&gt;, one for an efficient metadata index and one for binary file content. You can learn more about Hypercore from the &lt;a href=&quot;https://hypercore-protocol.org/&quot;&gt;Hypercore Protocol website&lt;/a&gt;. Hypercore gives us a fast and secure foundation for exchanging ordered blocks of data, but a good filesystem depends a good index.&lt;/p&gt;
&lt;div class=&quot;video-container&quot;&gt;
  &lt;video src=&quot;https://blog.hypercore-protocol.org/video/trie.mp4&quot; autoplay=&quot;&quot; loop=&quot;&quot; muted=&quot;&quot; playsinline=&quot;&quot;&gt;&lt;/video&gt;
&lt;/div&gt;
&lt;p&gt;To support performant filesystem operations, such as directory traversals, we&#39;ve layered a indexing data structure on top of Hypercore called a Hypertrie, which is an append-only implementation of a &lt;a href=&quot;https://en.wikipedia.org/wiki/Hash_array_mapped_trie&quot;&gt;hashed array-mapped trie&lt;/a&gt;. Painting a complete picture of Hypertrie is a blog post in itself, but the most important takeaway is that it lets us locate file/directory metadata, which is potentially scattered across many peers, using &lt;code&gt;O(log_4(n))&lt;/code&gt; network requests, worst case. In practice, we use a specialized Hypercore extension to make this dramatically faster (&lt;code&gt;O(1)&lt;/code&gt; in most cases).&lt;/p&gt;
&lt;h2 id=&quot;better-performance-and-reliability&quot;&gt;Better Performance and Reliability &lt;a class=&quot;direct-link&quot; href=&quot;#better-performance-and-reliability&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The Hypercore Protocol ecosystem has seen major improvements recently, and Hyperdrive directly benefits from all of them. Most significantly, Hyperdrive v10 leverages &lt;a href=&quot;https://github.com/mafintosh/hypertrie&quot;&gt;Hypertrie&lt;/a&gt; for &lt;strong&gt;better indexing&lt;/strong&gt;, and &lt;a href=&quot;https://github.com/hyperswarm/hyperswarm&quot;&gt;Hyperswarm&lt;/a&gt; for &lt;strong&gt;better networking&lt;/strong&gt;.&lt;/p&gt;
&lt;h3 id=&quot;networking&quot;&gt;Networking &lt;a class=&quot;direct-link&quot; href=&quot;#networking&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Hyperswarm is a Kademlia-backed DHT implementation that&#39;s designed specifically for the home. It uses a distributed approach to holepunching -- peers in the DHT can help bootstrap connections to other peers -- allowing us to traverse through the vast majority of home routers.&lt;/p&gt;
&lt;p&gt;Hyperswarm also comes full of heuristics designed to work around offline nodes and keep routing tables healthy. When combined with the holepunching, the heuristics make it dramatically faster to both discover and connect to peers.&lt;/p&gt;
&lt;h3 id=&quot;indexing&quot;&gt;Indexing &lt;a class=&quot;direct-link&quot; href=&quot;#indexing&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Hyperdrive v9 used an indexing data structure that worked well for small drives, but quickly broke down as drives or directories grew large. In v10 we&#39;re using &lt;a href=&quot;https://github.com/mafintosh/hypertrie&quot;&gt;Hypertrie&lt;/a&gt;. It scales nicely -- as a demo, we put a complete Wikipedia mirror (tens of millions of files, split across a few directories) into a drive, and reads remained very fast.&lt;/p&gt;
&lt;p&gt;We&#39;ll expand on Hypertrie in a follow-up post, but for now the main takeaway is that your directories can be as large as you (realistically) like, and file lookups will stay snappy!&lt;/p&gt;
&lt;h2 id=&quot;what&#39;s-new%3F&quot;&gt;What&#39;s New? &lt;a class=&quot;direct-link&quot; href=&quot;#what&#39;s-new%3F&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;For this release we&#39;ve focused on features that improve usability, simplify drive management, and reduce the friction of sharing. The two largest things we&#39;d like to introduce are &lt;strong&gt;mounts&lt;/strong&gt;, which let you create nested Hyperdrives, and the &lt;strong&gt;Hyperdrive daemon&lt;/strong&gt;, for serving as a one-stop shop for managing collections of drives.&lt;/p&gt;
&lt;h3 id=&quot;hyperdrive-mounts&quot;&gt;Hyperdrive Mounts &lt;a class=&quot;direct-link&quot; href=&quot;#hyperdrive-mounts&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Hypercore gives Hyperdrive many of its nice features, such as sparse downloading, for &amp;quot;free&amp;quot; -- the bulk of the work is handled at that layer. Hypercore, however, is fundamentally a single-writer data structure. A core&#39;s writer maintains a private key which is used to sign all appended data, making it possible for readers to exchange data amongst themselves without fear of tampering. Only letting one person (on one machine!) make changes to a drive is a big limitation, though. Not surprisingly, support for multiple writers has long been one of our most-requested features.&lt;/p&gt;
&lt;p&gt;In v10, we don&#39;t go all the way to a general multi-writer solution; solving multi-writer scalably, without incurring major performance penalties or confusing UX, remains a research question for us. That said, v10 introduces mounts, which are pretty much &amp;quot;links&amp;quot; to other Hyperdrives that look and act like normal directories.&lt;/p&gt;
&lt;div class=&quot;video-container&quot;&gt;
  &lt;video src=&quot;https://blog.hypercore-protocol.org/video/metadata-and-content-and-mounts.mp4&quot; autoplay=&quot;&quot; loop=&quot;&quot; muted=&quot;&quot; playsinline=&quot;&quot;&gt;&lt;/video&gt;
&lt;/div&gt;
&lt;p&gt;Mounts open up lots of opportunities, both for more granular sharing and for fun multi-user applications. On the sharing side, you might create a &lt;code&gt;projects/&lt;/code&gt; directory which contains mounts like &lt;code&gt;projects/my-module&lt;/code&gt;, &lt;code&gt;projects/my-website&lt;/code&gt; -- one drive for each thing you&#39;re working on. With mounts, you can share &lt;code&gt;my-website&lt;/code&gt; on its own, without giving away access to everything in &lt;code&gt;projects/&lt;/code&gt;. This pattern is especially handy in the daemon, which we&#39;ll talk about next.&lt;/p&gt;
&lt;p&gt;Things get more interesting when the drives you&#39;re mounting aren&#39;t your own.  We&#39;ve had a lot of success with a &amp;quot;groups&amp;quot; pattern, wherein a &amp;quot;group owner&amp;quot; first creates a top-level group drive, then mounts &amp;quot;user profiles&amp;quot; within the group:&lt;/p&gt;
&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;/my-group  // Owned by the group owner &lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;say User A&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br&gt;  /user-a  // Owned by User A&lt;br&gt;  /user-b  // Owned by User B&lt;br&gt;  &lt;span class=&quot;token punctuation&quot;&gt;..&lt;/span&gt;.&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Using this pattern, you can write simple &amp;quot;groupware&amp;quot; that aggregates content across users, using little more than a recursive &lt;code&gt;readdir&lt;/code&gt; on the group drive. For example, to find all blog posts in the group, you might search for all Markdown files in each user&#39;s &lt;code&gt;blog/&lt;/code&gt; directory.&lt;/p&gt;
&lt;h4 id=&quot;interested-in-using-mounts-now%3F&quot;&gt;Interested in using mounts now? &lt;a class=&quot;direct-link&quot; href=&quot;#interested-in-using-mounts-now%3F&quot;&gt;#&lt;/a&gt;&lt;/h4&gt;
&lt;p&gt;If you&#39;re using Hyperdrive directly, the &lt;code&gt;drive.mount(path, key, [opts])&lt;/code&gt; method is what you&#39;re after. It works as you&#39;d expect from the args (mount &lt;code&gt;key&lt;/code&gt; at &lt;code&gt;path&lt;/code&gt;), and the options can include a static drive version.&lt;/p&gt;
&lt;p&gt;It&#39;s also easy to create mounts in the daemon through the CLI, which we&#39;ll describe next.&lt;/p&gt;
&lt;h2 id=&quot;the-hyperdrive-daemon&quot;&gt;The Hyperdrive Daemon &lt;a class=&quot;direct-link&quot; href=&quot;#the-hyperdrive-daemon&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Hyperdrive is built with modular storage and networking in mind -- you can store drive contents however you like, and you can replicate them over any Node.js stream. This flexibility has benefits, but it makes it harder to get started. To that end, we&#39;ve created a cross-platform background service (a daemon) that handles storage/networking for you, while giving you a variety of ways to access daemon-managed drives.&lt;/p&gt;
&lt;p&gt;The daemon&#39;s a long-running service, so it can keep your drives online and available to readers. It&#39;s also great for DHT health: since the node on your computer is stable, the DHT&#39;s routing table contains fewer offline nodes. This translates to faster key lookups, meaning faster loading times.&lt;/p&gt;
&lt;p&gt;Most importantly, the daemon serves as a central point for exposing drives to external services -- currently we support a &lt;a href=&quot;https://grpc.io/&quot;&gt;gRPC&lt;/a&gt; API, with a corresponding &lt;a href=&quot;https://github.com/andrewosh/hyperdrive-daemon-client&quot;&gt;Node.js client library&lt;/a&gt;, and a FUSE interface.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/libfuse/libfuse&quot;&gt;FUSE&lt;/a&gt; allows us to emulate a native filesystem directory from within our Node.js code. It lets us turn Hyperdrives into normal directories on your computer! This means that whenever the daemon is running, you&#39;ll be able to access drives directly from within the OSX Finder, say, as virtual directories inside &lt;code&gt;~/Hyperdrive&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;With FUSE, drives are instantly accessible to other programs. You can watch movies using VLC, load PDFs using your favorite reader program, and use Unix utilities like &lt;code&gt;find&lt;/code&gt; and &lt;code&gt;ls&lt;/code&gt; to explore drives. We go into more depth in the &amp;quot;Getting Started&amp;quot; section below.&lt;/p&gt;
&lt;div class=&quot;video-container-lg&quot; id=&quot;tree-vid&quot;&gt;
  &lt;video src=&quot;https://blog.hypercore-protocol.org/video/tree4.mp4&quot; autoplay=&quot;&quot; loop=&quot;&quot; muted=&quot;&quot; playsinline=&quot;&quot;&gt;&lt;/video&gt;
&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;hyperdrive&lt;/code&gt; CLI tool contains a handful of commands both for interacting with FUSE, and for displaying information about drives. It also provides &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;export&lt;/code&gt; commands, for those users who don&#39;t want to mess around with &lt;code&gt;~/Hyperdrive&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;While the &lt;code&gt;~/Hyperdrive&lt;/code&gt; directory was added to simplify end-user UX, the gRPC API exists for developers -- you can now program with Hyperdrive in any language, without needing to deal with tricky networking APIs. If you&#39;re using Node.js, the client library gives you a &lt;code&gt;RemoteHyperdrive&lt;/code&gt; interface that feels exactly like a normal drive. To get started, jump &lt;a href=&quot;#With-the-Client-Library&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;We&#39;re hoping that the daemon provides a frictionless entry point both for end-users looking to share data, and for developers who want to build apps and services using Hyperdrive. If you have thoughts or feedback on the UX, don&#39;t hesitate to drop into our chat!&lt;/p&gt;
&lt;h2 id=&quot;getting-started&quot;&gt;Getting Started &lt;a class=&quot;direct-link&quot; href=&quot;#getting-started&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The best way to jump into the Hyperdrive stack is to install the daemon. This can be done through NPM:&lt;/p&gt;
&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;❯ &lt;span class=&quot;token function&quot;&gt;npm&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;install&lt;/span&gt; hyperdrive-daemon -g&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Once the daemon&#39;s installed, you&#39;ll have access to the &lt;code&gt;hyperdrive&lt;/code&gt; CLI command. From here, you have a few options. It&#39;s best to consult the &lt;a href=&quot;https://github.com/andrewosh/hyperdrive-daemon&quot;&gt;daemon&#39;s README&lt;/a&gt; for a more detailed guide, but we&#39;ll highlight the key steps here.&lt;/p&gt;
&lt;h3 id=&quot;with-fuse&quot;&gt;With FUSE &lt;a class=&quot;direct-link&quot; href=&quot;#with-fuse&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;em&gt;Note: FUSE is currently only available on Linux and OSX. The CLI&#39;s &lt;code&gt;import&lt;/code&gt; and &lt;code&gt;export&lt;/code&gt; commands can be used to move data in/out of drives on Windows.&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;Immediately after installation, you&#39;ll need to do a one-time setup step, which will request &lt;code&gt;sudo&lt;/code&gt; access -- don&#39;t worry, the daemon itself does not run as root. This is necessary in order to configure the bundled FUSE kernel modules:&lt;/p&gt;
&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;❯ hyperdrive fuse-setup&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;After this, start the daemon normally and you&#39;ll notice that your &lt;code&gt;~/Hyperdrive&lt;/code&gt; directory exist and contains a subdirectory called &lt;code&gt;Network&lt;/code&gt;. If you see &lt;code&gt;Network&lt;/code&gt;, you&#39;re good to go.&lt;/p&gt;
&lt;p&gt;As described in the walkthrough in the daemon README, &lt;code&gt;~/Hyperdrive&lt;/code&gt; is your &amp;quot;root drive,&amp;quot; which you can think of as a replacement for your Home directory. You can create subdirectories like Documents, Videos, or Projects in it, as you like.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;~/Hyperdrive/Network&lt;/code&gt; is a &amp;quot;magic directory&amp;quot; in that it does not actually exist inside of your root drive. It&#39;s there to make it easy to:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Get storage/networking statistics as json files in &lt;code&gt;Network/Stats&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;See which drives you&#39;re announcing to the swarm in &lt;code&gt;Network/Active&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Access any drive in the world by key at &lt;code&gt;Network/&amp;lt;drive-key&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Details about &lt;code&gt;Network&lt;/code&gt;, along with explanations of all the CLI commands you can use to populate and explore your root drive, can be found in the &lt;a href=&quot;https://github.com/andrewosh/hyperdrive-daemon#usage&quot;&gt;README&lt;/a&gt;.&lt;/p&gt;
&lt;h3 id=&quot;with-the-client-library&quot;&gt;With the Client Library &lt;a class=&quot;direct-link&quot; href=&quot;#with-the-client-library&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;If you have a daemon instance running, you can use the &lt;a href=&quot;https://github.com/andrewosh/hyperdrive-daemon-client&quot;&gt;&lt;code&gt;hyperdrive-daemon-client&lt;/code&gt;&lt;/a&gt; module to create &lt;code&gt;RemoteHyperdrive&lt;/code&gt; objects. Under the hood, these will send commands over gRPC to daemon-managed drives.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;RemoteHyperdrive&lt;/code&gt; API mirrors Hyperdrive&#39;s. The following code snippet will create a client instance, use that client to create a new drive, then write a file to the drive:&lt;/p&gt;
&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; HyperdriveClient &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&#39;hyperdrive-daemon-client&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;// Auto-connects to the daemon&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; client &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;HyperdriveClient&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token keyword&quot;&gt;await&lt;/span&gt; client&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;ready&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;// Creates a new drive and writes a file&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; drive &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;await&lt;/span&gt; client&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;drive&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token keyword&quot;&gt;await&lt;/span&gt; drive&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;writeFile&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&#39;foo.txt&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&#39;bar&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The daemon&#39;s README gives more examples. As of today, we only have a Node.js client, but the daemon&#39;s &lt;a href=&quot;https://github.com/andrewosh/hyperdrive-schemas/tree/master/schemas/daemon&quot;&gt;gRPC schemas&lt;/a&gt; are available, and we&#39;d welcome any efforts to create clients in other languages.&lt;/p&gt;
&lt;h3 id=&quot;with-beaker&quot;&gt;With Beaker &lt;a class=&quot;direct-link&quot; href=&quot;#with-beaker&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The &lt;a href=&quot;https://beakerbrowser.com/&quot;&gt;Beaker Browser&lt;/a&gt; makes heavy use of Hyperdrive internally. Beaker 1.0 Beta, which is also being released &lt;em&gt;today&lt;/em&gt;, actually installs and manages the daemon for you in the background! Beaker comes packed with authoring tools for creating P2P websites and sharing them with others.&lt;/p&gt;
&lt;p&gt;The &lt;a href=&quot;https://beaker.dev/&quot;&gt;Beaker developer portal&lt;/a&gt; contains thorough docs and tutorials (Tip: open that site in Beaker to make the tutorials interactive!), so you&#39;ll be off the ground immediately, building Hyperdrives containing fully-featured web applications (think personal wikis, photo albums, blog aggregators, and more).&lt;/p&gt;
&lt;p&gt;&lt;em&gt;You can find this blog post in Beaker at &lt;a href=&quot;hyper://e36050c2651b2bd0bd265fc311c122122a5490bc11a17606201964246b69e4ef&quot;&gt;hyper://e36050c2651b2bd0bd265fc311c122122a5490bc11a17606201964246b69e4ef&lt;/a&gt;!&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&quot;standalone&quot;&gt;Standalone &lt;a class=&quot;direct-link&quot; href=&quot;#standalone&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;You&#39;ll probably want to use the daemon/client most of the time, but in case you don&#39;t - perhaps in a one-off script or some kind of embedded scenario - you can use Hyperdrive as a module inside your program. The &lt;a href=&quot;https://github.com/hypercore-protocol/hyperdrive&quot;&gt;README&lt;/a&gt; shows you how, and it&#39;s also where you&#39;ll find complete API docs.&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://gist.github.com/andrewosh/1f3ae698ba42f7a382a5b85ab5305b88&quot;&gt;Here&#39;s a Gist&lt;/a&gt; containing a small, end-to-end example showing how to use Hyperswarm to discover and sync a Hyperdrive from another peer.&lt;/p&gt;
&lt;p&gt;In the future, we plan on making a few detailed tutorials about programmatic Hyperdrive usage. Remember, if you&#39;re looking for the simplest solution, check out the daemon and/or Beaker!&lt;/p&gt;
&lt;h2 id=&quot;looking-forward&quot;&gt;Looking Forward &lt;a class=&quot;direct-link&quot; href=&quot;#looking-forward&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;As you can see, a lot&#39;s been happening lately! But far more remains to be done. With these features released, here&#39;s a sketch of what we plan on tackling next.&lt;/p&gt;
&lt;h3 id=&quot;more-indexing-improvements&quot;&gt;More Indexing Improvements &lt;a class=&quot;direct-link&quot; href=&quot;#more-indexing-improvements&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The current implementation of Hypertrie&#39;s led to major gains. That said, it lacks a few features you might expect from a filesystem, most importantly atomic renames. Also, due to the way trie iteration works, both symlinks and mounts are slightly less efficient than they need to be.&lt;/p&gt;
&lt;p&gt;We&#39;ve been sitting on a new, heavily-fuzzed trie implementation for a while now, but we haven&#39;t had the cycles to integrate it yet. It supports symlinks (directly, as opposed to in the Hyperdrive layer), mounts, and atomic renames through a unified iterator abstraction that we&#39;re calling a &amp;quot;trie controller&amp;quot;. It&#39;s better all around.&lt;/p&gt;
&lt;p&gt;And don&#39;t worry, the new trie will be fully backwards-compat with the one we&#39;re releasing now.&lt;/p&gt;
&lt;h3 id=&quot;deduplication&quot;&gt;Deduplication &lt;a class=&quot;direct-link&quot; href=&quot;#deduplication&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;The daemon affords us many new opportunities by virtue of its both storing all drives in one location on disk, and handling networking in one place. By having total control of storage/networking, we can perform optimizations across your entire drive collection.&lt;/p&gt;
&lt;p&gt;On the networking side, we&#39;re investigating methods for deduplicating block requests that have already been satisfied by other drives. The end-goal here is: &amp;quot;you should never have to download the same data twice, even if its contained in different drives&amp;quot;.&lt;/p&gt;
&lt;p&gt;On the storage side, we&#39;re considering supporting content-addressed block storage, meaning if you have two similar drives, only the set of unique blocks will be persisted on disk -- common blocks will only be stored once.&lt;/p&gt;
&lt;h3 id=&quot;random-access-writes&quot;&gt;Random-Access Writes &lt;a class=&quot;direct-link&quot; href=&quot;#random-access-writes&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;While a writer can update their drives however they like (i.e. adding new files, deleting files, appending to files, etc.), certain operations are more efficient than others. Unfortunately, editing existing files is one of the inefficient ones -- it currently results in file duplication. This is bad news if you want to run a database on FUSE or append to log files.&lt;/p&gt;
&lt;p&gt;There are two ways to remedy this:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Better garbage collection, where old versions of files can be cleared from disk easily (fine for simple cases, but still bad for databases).&lt;/li&gt;
&lt;li&gt;Efficient file updates, where writing to an existing file does not lead to data copying.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We&#39;re exploring various approaches based on &lt;a href=&quot;https://en.wikipedia.org/wiki/Inode&quot;&gt;inodes&lt;/a&gt; for (2). As with general multiwriter, there&#39;s a tricky balancing act involved. An index that supports these updates will unavoidably increase read latencies for files that don&#39;t have random-access modifications. This won&#39;t cut it if you&#39;re watching a large movie, never modified after it was first written, from start to end.&lt;/p&gt;
&lt;p&gt;We&#39;ll surely have to use a hybrid approach; we&#39;re still actively researching this.&lt;/p&gt;
&lt;h3 id=&quot;garbage-collection&quot;&gt;Garbage Collection &lt;a class=&quot;direct-link&quot; href=&quot;#garbage-collection&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;As described above, the append-only nature of file updates means that we&#39;re not exactly being conservative with your disk space. Hyperdrive does not currently support clearing old file versions, but we&#39;ve taken a step in that direction with &amp;quot;tags.&amp;quot;&lt;/p&gt;
&lt;p&gt;Using tags, you can assign names to drive versions you&#39;d like to keep around. We&#39;ll shortly be adding support for a &lt;code&gt;clearUntagged&lt;/code&gt; method that will remove untagged file versions from disk.&lt;/p&gt;
&lt;p&gt;With &lt;code&gt;clearUntagged&lt;/code&gt;, random-access writes become less essential, so we&#39;re hoping it will serve as a nice near-term stopgap.&lt;/p&gt;
&lt;h3 id=&quot;union-mounts&quot;&gt;Union Mounts &lt;a class=&quot;direct-link&quot; href=&quot;#union-mounts&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Mounts currently cannot overlap with one another. The group model works around this limitation, enabling useful multi-user applications, but there are many cases where you&#39;d like to display a &amp;quot;merged view&amp;quot; over many drives.&lt;/p&gt;
&lt;p&gt;To accomplish this, we&#39;re thinking about ways to extend mounts. The &amp;quot;trie controller&amp;quot; design we alluded to above makes experimentation easier here. A simple union mounts feature, without any opinionated conflict resolution (i.e. displaying conflicting files side-by-side), is a natural next step.&lt;/p&gt;
&lt;p&gt;A general multiwriter solution, with customizable hooks for conflict resolution, remains on our to-do list, but that&#39;s still a far-future feature. We want to see how far we can go with mounts first.&lt;/p&gt;
&lt;h2 id=&quot;many-thanks&quot;&gt;Many Thanks &lt;a class=&quot;direct-link&quot; href=&quot;#many-thanks&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Gearing up for this release has been a big group effort over the past year, and we owe a lot to the many contributors in the Dat community who have helped test alpha versions of the stack, fix bugs, and review docs.&lt;/p&gt;
&lt;p&gt;A very special thanks goes to Samsung, whose generous &lt;a href=&quot;https://samsungnext.com/&quot;&gt;Samsung Next&lt;/a&gt; grant funded a massive chunk of this work. Huge thanks to Ricardo and the rest of the Samsung Next team!&lt;/p&gt;
&lt;h2 id=&quot;learning-more&quot;&gt;Learning More &lt;a class=&quot;direct-link&quot; href=&quot;#learning-more&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;To learn more about how Hyperdrive works under the hood, your best bet is to check out the source code on GitHub. Our code&#39;s currently split across a number of repos, most within the &lt;a href=&quot;https://github.com/hypercore-protocol&quot;&gt;Hypercore Protocol&lt;/a&gt; organization. Here are a few direct links to the stuff we&#39;ve discussed in this post:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/hypercore-protocol/hyperdrive&quot;&gt;Hyperdrive&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/hypercore-protocol/hyperdrive-daemon&quot;&gt;Hyperdrive Daemon&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/hypercore-protocol/hypercore&quot;&gt;Hypercore&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/hyperswarm/hyperswarm&quot;&gt;Hyperswarm&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/hypercore-protocol/hypertrie&quot;&gt;Hypertrie&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;chat-with-us&quot;&gt;Chat with us &lt;a class=&quot;direct-link&quot; href=&quot;#chat-with-us&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;If you have questions about Hyperdrive&#39;s design, or want to talk about the stack, message us on &lt;a href=&quot;https://chat.hypercore-protocol.org/&quot;&gt;Discord&lt;/a&gt; -- that&#39;s where we&#39;ll be having development-oriented conversations.&lt;/p&gt;
&lt;p&gt;If you run into any bugs, go ahead and open issues on our &lt;a href=&quot;https://github.com/hypercore-protocol/community&quot;&gt;Community repo&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;And also feel free to send DMs to anyone on the team:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://twitter.com/mafintosh&quot;&gt;@mafintosh&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://twitter.com/pfrazee&quot;&gt;@pfrazee&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://twitter.com/andrewosh&quot;&gt;@andrewosh&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;credits&quot;&gt;Credits &lt;a class=&quot;direct-link&quot; href=&quot;#credits&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Big thanks to &lt;a href=&quot;https://twitter.com/mafintosh&quot;&gt;@mafintosh&lt;/a&gt; for the visualizations and &lt;a href=&quot;https://twitter.com/pfrazee&quot;&gt;@pfrazee&lt;/a&gt; for proofreading.&lt;/p&gt;
&lt;p&gt;In our demo videos, we used content from The Internet Archive&#39;s &lt;a href=&quot;https://archive.org/details/academictorrents_c8b687c984d3d902310f27d56759ed69f5e1b4a7&quot;&gt;van Gogh collection&lt;/a&gt;.&lt;/p&gt;
</content>
	</entry>
	
	<entry>
		<title>Hyperspace: A Minimal Hypercore Server</title>
		<link href="https://blog.hypercore-protocol.org/posts/hyperspace/"/>
		<updated>2020-09-17T02:00:00+02:00</updated>
		<id>https://blog.hypercore-protocol.org/posts/hyperspace/</id>
		<content type="html">&lt;h3 id=&quot;quick-primer&quot;&gt;Quick Primer &lt;a class=&quot;direct-link&quot; href=&quot;#quick-primer&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;If you&#39;re already familiar with the Hypercore Protocol, feel free to skip over this bit. If not, here&#39;s a quick overview of our modules to get you up to speed.&lt;/p&gt;
&lt;p&gt;The Hypercore Protocol consists of three things:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;An append-only log structure (&lt;strong&gt;Hypercore&lt;/strong&gt;) designed for fast, secure replication between peers in peer-to-peer networks. Hypercore is our core primitive.&lt;/li&gt;
&lt;li&gt;A DHT implementation that works well in home networks (&lt;strong&gt;Hyperswarm&lt;/strong&gt;). We mainly use this for discovering and replicating Hypercores.&lt;/li&gt;
&lt;li&gt;A few higher-level data structures built on top of Hypercores (&lt;strong&gt;Hyperdrive&lt;/strong&gt;, &lt;strong&gt;Hypertrie&lt;/strong&gt;), for constructing filesystems and kv-stores.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Hypercore and Hyperswarm are the &amp;quot;foundational&amp;quot; pieces of the stack -- our other modules build on top of them. One such module, &lt;strong&gt;Corestore&lt;/strong&gt;, provides a convenience layer for managing collections of Hypercores, which is useful in the higher-level data structures like Hyperdrive.&lt;/p&gt;
&lt;h2 id=&quot;intro&quot;&gt;Intro &lt;a class=&quot;direct-link&quot; href=&quot;#intro&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Back in May, we released Hyperdrive v10, which introduced major new features, like indexing improvements and mounts. To get folks off the ground quickly, we paired v10 with a new Hyperdrive daemon, providing simple, out-of-the-box answers for managing drive storage and Hyperswarm networking. The daemon was designed for ease of use and diverse use-cases, bundling a CLI, a gRPC API, and FUSE support. We imagined &lt;code&gt;hyperdrive start&lt;/code&gt; getting you 90% of the way to creating and sharing drives, without burdoning you with many technical details. If you&#39;re intested in how we approached this, check out our earlier &lt;a href=&quot;https://blog.hypercore-protocol.org/posts/hyperspace/&quot;&gt;blog post&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Our relationship with the daemon was bright but brief! It&#39;s been working (mostly) reliably in the &lt;a href=&quot;https://beakerbrowser.com/&quot;&gt;Beaker 1.0 Beta&lt;/a&gt;, and for the first time it let us ship a single, unified product. That said, after launch we began adding support for new Hypercore-based data structures, and we realized this would require both substantial refactoring of the daemon internals and extensions to the API. At the end of the day, the daemon was built with Hyperdrives in mind, and we saw a future of complexity and bloat in extending its scope in that direction.&lt;/p&gt;
&lt;p&gt;We&#39;re always looking to simplify and streamline our stack, so with minimalism in mind we started experimenting with a more flexible implementation. Those experiments turned out nicely, and Hyperspace is the result.&lt;/p&gt;
&lt;h2 id=&quot;what-is-hyperspace%3F&quot;&gt;What is Hyperspace? &lt;a class=&quot;direct-link&quot; href=&quot;#what-is-hyperspace%3F&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Hyperspace is a lightweight service that provides remote access to Hypercores/Hyperswarm, and nothing more -- where the daemon gave you &lt;code&gt;RemoteHyperdrive&lt;/code&gt;, Hyperspace gives you &lt;code&gt;RemoteHypercore&lt;/code&gt;. Since Hypercore and Hyperswarm are the foundational bits in our ecosystem, centering our primary service around them caters to a broader set of users. When compared to the Hyperdrive daemon, Hyperspace has a tiny scope, but keeping the scope small enables a vastly larger opportunities in userland.&lt;/p&gt;
&lt;p&gt;As an example of where this simplicity shines, a &amp;quot;remote Hyperdrive&amp;quot; built on Hyperspace is actually just a regular old Hyperdrive, but with &lt;code&gt;RemoteHypercores&lt;/code&gt; inside. Previously, adding support for a new Hyperdrive feature involved implementing the feature, updating API schemas, and adding methods to the daemon/client. With Hyperspace, new Hyperdrive features can live in Hyperdrive alone.&lt;/p&gt;
&lt;p&gt;As with the daemon, Hyperspace handles storage and networking for you: the Hypercores it manages are all stored in a single location on-disk (inside the &lt;code&gt;~/.hyperspace/storage&lt;/code&gt; directory), and the server keeps a long-running Hyperswarm node online for you. As far as features go, there really are only two:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;RemoteHypercore&lt;/code&gt;, &lt;code&gt;RemoteNetworker&lt;/code&gt;, and &lt;code&gt;RemoteCorestore&lt;/code&gt; APIs served over a tiny RPC system. We&#39;ll never add anything beyond these, to keep things simple.&lt;/li&gt;
&lt;li&gt;A Node.js client library&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We&#39;ve also gotten rid of PM2 in Hyperspace -- the service only runs in the foreground and isn&#39;t a daemon. This should make it easier to use with a wider variety of process managers, like systemd or a tray app.&lt;/p&gt;
&lt;h3 id=&quot;the-api&quot;&gt;The API &lt;a class=&quot;direct-link&quot; href=&quot;#the-api&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;We&#39;re constantly adding new features to the higher-level data structures (like Hyperdrive), but the Hypercore and Hyperswarm APIs are updated relatively infrequently. We can take advantage of that to keep the Hyperspace API as small and stable as possible. We also wanted the API to be clear and easy-to-use, so we opted to use a custom binary RPC system called &lt;a href=&quot;https://blog.hypercore-protocol.org/posts/hyperspace/&quot;&gt;HRPC&lt;/a&gt; instead of gRPC.&lt;/p&gt;
&lt;p&gt;Like gRPC, &lt;a href=&quot;https://blog.hypercore-protocol.org/posts/hyperspace/&quot;&gt;HRPC service definitions&lt;/a&gt; are written as Protocol Buffers schemas. Unlike gRPC, HRPC is transport-agnostic (you can easily pipe it over a WebSocket, for example) and has simpler built-in error handling, which assists in debugging. It&#39;s super easy to use, and it&#39;s a much smaller dependency to boot.&lt;/p&gt;
&lt;h3 id=&quot;the-client-library&quot;&gt;The Client Library &lt;a class=&quot;direct-link&quot; href=&quot;#the-client-library&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;We&#39;ve shot for API parity between &lt;a href=&quot;https://blog.hypercore-protocol.org/posts/hyperspace/&quot;&gt;&lt;code&gt;Corestore&lt;/code&gt;&lt;/a&gt;, &lt;a href=&quot;https://blog.hypercore-protocol.org/posts/hyperspace/&quot;&gt;&lt;code&gt;Hypercore&lt;/code&gt;&lt;/a&gt;, the &lt;a href=&quot;https://blog.hypercore-protocol.org/posts/hyperspace/&quot;&gt;&lt;code&gt;@corestore/networker&lt;/code&gt;&lt;/a&gt; and their remote counterparts. As such you should be able to drop a &lt;code&gt;RemoteHypercore&lt;/code&gt; into any module that currently consumes a &lt;code&gt;Hypercore&lt;/code&gt;, and likewise for the other two.&lt;/p&gt;
&lt;p&gt;As an example, updating Hyperdrive to use &lt;code&gt;RemoteHypercores&lt;/code&gt; was just a matter of dropping in a &lt;code&gt;RemoteCorestore&lt;/code&gt; as the first argument:&lt;/p&gt;
&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; hyperdrive &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&#39;hyperdrive&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt; Client&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; HyperspaceClient &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&#39;hyperspace&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;br&gt;&lt;span class=&quot;token comment&quot;&gt;// Assumes the Hyperspace service is already running.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; client &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;HyperspaceClient&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; drive &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;hyperdrive&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;client&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;corestore&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;trying-it-out&quot;&gt;Trying it Out &lt;a class=&quot;direct-link&quot; href=&quot;#trying-it-out&quot;&gt;#&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;First, install hyperspace globally with &lt;code&gt;npm i hyperspace -g&lt;/code&gt;. Once installed, you&#39;ll have a &lt;code&gt;hyperspace&lt;/code&gt; CLI command which can be used to start the service:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;❯ hyperspace
Running hyperspace/3.6.1 linux-x64 node-v12.17.0
Listening on /tmp/hyperspace.sock
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Importantly, if you&#39;re an existing Hyperdrive daemon user, the Hyperspace server will read from your existing Hypercores (stored in &lt;code&gt;~/.hyperdrive&lt;/code&gt;), whereas new users can find their cores in &lt;code&gt;~/.hyperspace&lt;/code&gt;. This lets you run the old and the new on the same storage directory, keeping things compatible. In the future, launching Hyperspace will perform a migration, moving data from &lt;code&gt;~/.hyperdrive&lt;/code&gt; to &lt;code&gt;~/.hyperspace&lt;/code&gt;. Once this migration is done, your Hyperdrive daemon will no longer work (unless you manually move the data), so there&#39;s no looking back!&lt;/p&gt;
&lt;h2 id=&quot;the-new-and-improved-hyperdrive-service&quot;&gt;The New and Improved Hyperdrive Service &lt;a class=&quot;direct-link&quot; href=&quot;#the-new-and-improved-hyperdrive-service&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;While Hyperspace introduces major architectural changes to the stack, we&#39;ve been careful to preserve the Hyperdrive daemon&#39;s functionality. Since FUSE and the CLI are only relevant for Hyperdrives, we&#39;ve created a separate companion service for these components, &lt;a href=&quot;https://github.com/hyperspace-org/hyperdrive-service&quot;&gt;&lt;code&gt;@hyperspace/hyperdrive&lt;/code&gt;&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Being a companion service, &lt;code&gt;@hyperspace/hyperdrive&lt;/code&gt; is designed to run alongside Hyperspace. If you&#39;re an existing user of the Hyperdrive daemon, you shouldn&#39;t notice any major changes. Installing the module globally will give you the same &lt;code&gt;hyperdrive&lt;/code&gt; CLI as before.&lt;/p&gt;
&lt;p&gt;If you&#39;ve been using the &lt;code&gt;client.fuse&lt;/code&gt; API in the &lt;code&gt;hyperdrive-daemon-client&lt;/code&gt; module, that logic has been moved into the Hyperdrive service&#39;s client library:&lt;/p&gt;
&lt;pre class=&quot;language-javascript&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; fuseClient &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;require&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&#39;@hyperspace/hyperdrive/client&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;token keyword&quot;&gt;await&lt;/span&gt; fuseClient&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token string&quot;&gt;&#39;/home/andrew/Hyperdrive/my-mount&#39;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As part of this refactor, we&#39;ve also gone ahead and added some flexibility on the FUSE side of things. Your root drive can now be mounted anywhere, not just at &lt;code&gt;~/Hyperdrive&lt;/code&gt;, and we put together a handful of end-to-end FUSE tests to keep things reliable.&lt;/p&gt;
&lt;h2 id=&quot;compatibility-additions-to-the-daemon-client&quot;&gt;Compatibility Additions to the Daemon Client &lt;a class=&quot;direct-link&quot; href=&quot;#compatibility-additions-to-the-daemon-client&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;The daemon&#39;s gRPC API is now deprecated, but we didn&#39;t want to introduce significant breaking changes for users of the &lt;code&gt;hyperdrive-daemon-client&lt;/code&gt; module. The 2.0 release of the client serves as a compatibility release -- it&#39;s a &amp;quot;drop-in&amp;quot; replacement for the 1.0 version, but is designed to work with Hyperspace instead.&lt;/p&gt;
&lt;p&gt;There are a few small differences, though, hence the major bump. The &lt;code&gt;fuse&lt;/code&gt; API has been moved into &lt;code&gt;@hyperspace/hyperdrive&lt;/code&gt;, and the &lt;code&gt;peersockets&lt;/code&gt; API just directly proxies to a &lt;a href=&quot;https://github.com/andrewosh/peersockets&quot;&gt;Peersockets 1.0&lt;/a&gt; instance. The 1.0 release of Peersockets has a couple of breaking changes as described in &lt;a href=&quot;https://github.com/andrewosh/peersockets/blob/master/UPGRADE.md&quot;&gt;UPGRADE.md&lt;/a&gt;, which were introduced in order to be consistent with Hypercore extension usage.&lt;/p&gt;
&lt;p&gt;If you&#39;re just getting started with the stack, we recommend using &lt;a href=&quot;https://github.com/hypercore-protocol/hyperdrive&quot;&gt;&lt;code&gt;hyperdrive&lt;/code&gt;&lt;/a&gt; with a &lt;code&gt;RemoteCorestore&lt;/code&gt; instead of the &lt;code&gt;hyperdrive-daemon-client&lt;/code&gt;, as described above. We expect the 2.0 client release to tide folks over while they transition to using Hyperdrive directly, but the client is now considered &amp;quot;soft deprecated&amp;quot;.&lt;/p&gt;
&lt;h2 id=&quot;stay-in-touch&quot;&gt;Stay in Touch &lt;a class=&quot;direct-link&quot; href=&quot;#stay-in-touch&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Having tested Hyperspace for a few months now, we&#39;re very excited about this release. You might still hit a few bugs here or there, so you can reach us and join the discussion in the &lt;a href=&quot;https://chat.hypercore-protocol.org/&quot;&gt;Hypercore Protocol Discord&lt;/a&gt;. As always, feel free to open issues on the GitHub repos as well.&lt;/p&gt;
&lt;h2 id=&quot;thanks&quot;&gt;Thanks &lt;a class=&quot;direct-link&quot; href=&quot;#thanks&quot;&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;And thanks to the community members who have jumped in to fix bugs, add docs, and explore what Hyperspace can do. You definitely won&#39;t want to miss &lt;a href=&quot;https://github.com/frando/hyperspace-rs&quot;&gt;Frando&#39;s Rust implementation&lt;/a&gt;, which paves the way for working with classic, Node-based Hypercores in Rust, and &lt;a href=&quot;https://github.com/datrs&quot;&gt;vice versa&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;- Andrew and team&lt;/p&gt;
</content>
	</entry>
</feed>
